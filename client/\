package client

import (
	"errors"
	"net/http"
	"time"

	"github.com/Comcast/webpa-common/xhttp"
	"github.com/Comcast/webpa-common/xmetrics"
	"github.com/go-kit/kit/log"
	"github.com/spf13/viper"
)

type WebPAClient struct {
	om     OutboundMeasures
	client func(*http.Request) (*http.Response, error)
}

func NewWebPAClient(r xmetrics.Registry, t func(*http.Request) (*http.Response, error)) *WebPAClient {
	return &WebPAClient{
		om:     NewOutboundMeasures(r),
		client: t,
	}
}

func (w *WebPAClient) Transact(r *http.Request) (*http.Response, error) {
	return w.client(r)
}

func (w *WebPAClient) RetryTransact(r *http.Request, ro xhttp.RetryOptions) (*http.Response, error) {

	rt := xhttp.RetryTransactor(ro, w.client)

	return rt(r)

}

func Initialize(v *viper.Viper, r xmetrics.Registry, l log.Logger, sr xhttp.ShouldRetryFunc, sl func(time.Duration)) (*WebPAClient, error) {
	clientConfig, err := viperToHTTPClientConfig(v)
	if err != nil {
		return nil, err
	}

	om := NewOutboundMeasures(r)

	ok := clientConfig.retryOptionsConfig.IsEmpty()
	switch ok {
	case false:
		retryOptions := xhttp.RetryOptions{
			Logger:      l,
			Interval:    clientConfig.retryOptionsConfig.interval(),
			Retries:     clientConfig.retryOptionsConfig.retries(),
			Sleep:       sl,
			ShouldRetry: sr,
			// Counter:     om.Retries,
		}

		transactor := clientConfig.NewTransactor(om, sr, sl, l)
		transactor = xhttp.RetryTransactor(retryOptions, transactor)

		return newWebPAClient(r, transactor), nil
	case true:
		client := clientConfig.NewClient()

		return newWebPAClient(r, client.Do), nil
	default:
		return nil, errors.New("Failed to initialize webPAClient")
	}
}
